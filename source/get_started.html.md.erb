# Getting Started with Hyperloop

Welcome to Hyperloop, the missing ruby front end library. Building highly interactive web applications should not be difficult.

This introduction will take you through most of what you need to know to get started with Hyperloop. The code snippets are editable so please feel free to experiment as you read along.

## Components

There are five important ingreditets to th Hyperloop architecture. We will start with Components which are a fantastic way of building interactive web pages. Let's have a look at a basic Component:

<!-- <%= render_code_component(
  heading: "A simple Hyperloop Component",
  code:
"class ExampleComponent < React::Component::Base
  render(DIV) do
    BUTTON { 'Push the button' }.on(:click) do
     alert 'You did it!'
    end
  end
end"
)%> -->

<div class="codemirror-live-edit"
  data-component="PushButton"
  data-heading="A simple Component rendering a Button">
<pre>
class ExampleComponent < React::Component::Base
  render(DIV) do
    BUTTON { 'Push the button' }.on(:click) do
     alert 'You did it!'
    end
  end
end
</pre></div>


<div class="codemirror-live-edit"><pre>
class ExampleComponent < React::Component::Base
  render(DIV) do
    H1 { "and text william" }
  end
end
</pre></div>


There are a few things to notice in the code above.

+ Components are Ruby Classes which inherit from `React::Component::Base`. Underneath this we are wrapping FaceBook's React. A Hyperloop Component is a Ruby implementation of a React JavaScript Component.
+ Every Component must have a `render` macro which must return just one HTML element. The syntax of `render(DIV)` is a shorthand for this which will return one div.
+ HTML elements (DIV, BUTTON, etc) can be in uppercase or lowercase.

### Components render other Components

A Component based architecture encourages you to write simple coponents that preform single tasks and render other Components. There are no ERB template files,


## old
## Reactive Updates

Open `hello-react.html` in a web browser and type your name into the text field. Notice that React is only changing the time string in the UI â€” any input you put in the text field remains, even though you haven't written any code to manage this behavior. React figures it out for you and does the right thing.

The way React figures this out is that it does not manipulate the DOM unless it needs to. **It uses a fast, internal mock DOM to perform diffs and computes the most efficient DOM mutation for you.**

The inputs to this component are called `params` (*called props in react.js*). They are passed as a hash to the component.

## Components are Ruby Classes


The React philosophy is that components are the right way to separate concerns rather than by "templates" and "display logic."  This is because the resulting markup and the code that generates it are intimately tied together.  Additionally, display logic is often very complex and using template languages to express it becomes cumbersome.

The HyperReact approach is to generate HTML and component trees directly right in the component class using Ruby so that you can use all of Ruby's expressive power when building your UI.

To enable this every HyperReact component class has access to set of class and instance methods that makes specifying the component, and building HTML and event handlers straightforward.

For example within the render method the `a` method generates an anchor tag like this:

```ruby
a(href: 'https://github.com/ruby-hyperloop') { 'Get Hyperloop' }
```

Under the hood everything maps to React.js function calls in a straight forward manner.  The HyperReact DSL is roughly analogous to the React.js JSX, but because its "just ruby" you don't have to learn a new language, and switch mental gears while writing code.
