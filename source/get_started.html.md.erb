# Getting Started with Hyperloop

This introduction will take you through most of what you need to know to get started with Hyperloop. There are live code examples, so please feel free to experiment as you read.

There are five important ingredients to the Hyperloop architecture (COMPS for short):

+ **Components** describe how the UI will display the *current* application state and how it will handle user actions.  Using React Components automatically rerender parts of the display as state changes due to local or remote activities.
+ **Operations (coming soon)** encapsulate activities. In an MVC architecture operations end up either in controllers, models or some other secondary construct such as service objects, helpers, or concerns. Here they are first class objects.
+ **Models** can now focus on one thing and that is the structure of the data as it is persisted.  Any business logic is moved to Operations.
+ **Policies** keep authorization logic out of models, and operations, and also allows the isomorphic transport mechanism to know what and when to communicate between client and server.
+ **Stores** hold application state. Stores are Ruby classes that keep the dynamic parts of the state in special state variables.

This Getting Started guide will introduce you to our Components. After reading this you might like to try some of the [Tutorials](/tutorials) or jump into the [Docs](/docs/architecture) for a comprehensive overview of the Hyperloop architecture.

## Components

Hyperloop user interfaces are composed of React Components written in Ruby.

Here is the basic structure of a Component:

```ruby
class StrippedBackComponent < React::Component::Base
  render(DIV) do
  end
end
```

As you can see, a Component is just a Ruby class which inherits from `React::Component::Base`. At a minimum, a Component must implement a `render` macro that returns just one HTML element. Under the covers, HyperReact used Opal to compile this Component into JavaScript then hands it to React to mount as a regular JavaScript React Component.

As with React, there are no templates in Hyperloop, your user interface is made up of Components which mix conditional logic and HTML elements to build the user interface. Unlike React, where you code in JSX and JavaScript, Hyperloop lets you keep all your code in Ruby.

Let's add a little functionality to this Component - you can edit this code if you would like to experiment.

<div class="codemirror-live-edit"
  data-heading="A simple Component rendering a Button"
  data-rows=9>
<pre>
class ExampleComponent < React::Component::Base
  render(DIV) do
    BUTTON { 'Push the button' }.on(:click) do
     alert 'You did it!'
    end
  end
end
</pre></div>


There are a few things to notice in the code above.

+ Every Component must have a `render` macro which must return just one HTML element. The syntax of `render(DIV)` is a shorthand for this which will return one div.
+ HTML elements (DIV, BUTTON, etc) can be in uppercase or lowercase.
+ We added an event handler to the button. You can do this for any HTML element in the same way.

### Components render Components

Hyperloop's architecture encourages you to write simple Components that perform single tasks and render other Components.

```ruby
class App < React::Component::Base
  render(DIV) do
    MainNavigation {}
    PageContents {}
    Footer {}
  end
end
```

This simple approach allows you to build complicated user interfaces yet encapsulate functionality into reusable contained entities.

### Passing parameters

Data is passed downward from a parent Component to its children. There are various techniques for passing data upward and (better still) keeping data in **Stores** independently of Components but we will address that later.

For now, let's experiment with passing parameters:

<div class="codemirror-live-edit"
  data-heading="Passing parameters">
<pre>
class ExampleComponent < React::Component::Base
  render(DIV) do
    SayHelloTo(name: "John")
    SayHelloTo(name: "Sally")
  end
end

class SayHelloTo < React::Component::Base
  param :name, type: String

  render(DIV) do
    H4 { "Hello #{params.name}!" }
  end
end
</pre></div>

You will notice a couple of things in the code above:

+ The syntax for adding components is either `MyComponent()` or `MyComponent {}` but never just `MyComponent`. Sometimes you use both - `button(style: default) { "Click Me" }`. Everything in the brackets is passed to the Component as a parameter and everything in the curly brace is rendered within the Component.
+ Parameters can be strongly typed `param :name, type: String` and considering this code will be compiled to JavaScript this is a good idea.

### State and conditional execution

One of the greatest things about React is that it encourages you to write code in a declarative way with Components that manage their own state. As state changes, React works out how to render the user interface without you having to worry about the DOM. As state changes, the user interface re-renders itself.

Lets experiment with an example:

<div class="codemirror-live-edit"
  data-heading="Using state"
  data-rows=30>
<pre>
class ExampleComponent < React::Component::Base
  define_state show_field: false
  define_state field_value: ""

  render(DIV) do
    show_button
    DIV do
      show_input
      H1 { "#{state.field_value}" }
    end if state.show_field
  end

  def show_button
    BUTTON do
      state.show_field ? "Hide" : "Show"
    end.on(:click) { state.show_field! !state.show_field }
  end

  def show_input
    BR {}
    INPUT(type: :text).on(:change) do |e|
      state.field_value! e.target.value
    end
  end

  def show_text
    H1 { "#{state.field_value}" }
  end
end</pre></div>

A few things to notice in the code above:

+ We define state using the `define_state` macro. Notice how we set the initial value.
+ To reference state we use `state.something` and `state.mutate.something =` (or previously `state.something!`) is used to update state
+ Components are just Ruby classes which have methods.
+ Here is the most important part - notice how React automatically updates the user interface as state changes. This is the very heart of React thinking.

### Stylish Components

Conditional logic, HTML elements, state and style all intermingle in a Hyperloop Component. This website uses Bootstrap CSS, so we have complete access to the Bootstrap CSS from within our Components.

<div class="codemirror-live-edit"
  data-heading="Using CSS"
  data-rows=23>
<pre>
class ExampleComponent < React::Component::Base
  render(DIV) do
    table.table.table_bordered do
      thead do
        tr do
          th { "First Name" }
          th { "Last Name" }
          th { "Username" }
          th { }
        end
      end
      tbody do
        tr do
          td { "Mark" }
          td { "Otto" }
          td.text_success { "@odm" }
          td { button.btn.btn_primary.btn_sm { "Edit" } }
        end
      end
    end
  end
end</pre></div>

As you can see above, CSS is mixed into HTML elements. `div.something` becomes `<div class="something">`. Also note that `btn-primary` becomes `btn_primary` as `-` is not allowed in a name in Ruby.

### The complete JavaScript universe at your disposal

Hyperloop gives you full access to all JavaScript libraries and components from directly within your Ruby code. Everything you can do in JavaScript is simple to do in ruby, this includes passing parameters between Ruby and JavaScript and even passing in Ruby lambdas as JavaScript callbacks. All of this magic comes from Opal.

JavaScript components are accessed directly from within your Ruby code. We have a tutorial which will show you exactly how this works.

```ruby
class ExampleComponent < React::Component::Base
  render(DIV) do
    ReactPlayer(url:  'https://www.youtube.com/embed/FzCsDVfPQqk',
      playing: false
    )
  end
end
```

We hope you have enjoyed this introduction to Hyperloop. As a next step, perhaps try some of the [Tutorials](/tutorials) or jump into the [Docs](/docs/architecture) for a comprehensive overview of the Hyperloop architecture.

Welcome aboard!
